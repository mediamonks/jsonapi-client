declare type ObjectWith<K extends PropertyKey> = {
  [P in K]: unknown
}
export declare type Predicate<T> = (
  value: unknown | any,
  ...rest: Array<unknown>
) => value is T
export declare type Static<T extends Predicate<any>> = T extends Predicate<
  infer R
>
  ? R
  : never
export declare type Constructor<T> = {
  new (...rest: Array<any>): T
}
export declare type Intersect<T> = (T extends any
  ? (k: T) => void
  : never) extends ((k: infer I) => void)
  ? I
  : never
export declare type None = null | undefined
export declare type Some =
  | Function
  | boolean
  | bigint
  | number
  | string
  | symbol
  | object
export declare type ObjectLike = ObjectWith<PropertyKey>
export declare type Primitive =
  | null
  | undefined
  | boolean
  | number
  | string
  | symbol
  | bigint
export interface SerializableArray<T extends Serializable> extends Array<T> {}
export declare type SerializablePrimitive = null | boolean | number | string
export declare type SerializableObject = {
  [key: string]: Serializable
}
export declare type Serializable =
  | SerializablePrimitive
  | SerializableObject
  | SerializableArray<any>
export {}
