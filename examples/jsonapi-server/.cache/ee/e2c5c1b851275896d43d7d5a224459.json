{"id":"ZCUZ","dependencies":[{"name":"/Users/nathanuphoff/Projects/~lab/jsonapi-client/tsconfig.json","includedInParent":true,"mtime":1563545694388},{"name":"/Users/nathanuphoff/Projects/~lab/jsonapi-client/examples/jsonapi-server/package.json","includedInParent":true,"mtime":1565006981869},{"name":"./constants","loc":{"line":1,"column":28},"parent":"/Users/nathanuphoff/Projects/~lab/jsonapi-client/src/utils/generics.ts","resolved":"/Users/nathanuphoff/Projects/~lab/jsonapi-client/src/utils/constants.ts"}],"generated":{"js":"\"use strict\";var r=require(\"./constants\");"},"sourceMaps":{"js":{"mappings":[{"source":"../../src/utils/generics.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":1,"column":0}},{"source":"../../src/utils/generics.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":1,"column":13}},{"source":"../../src/utils/generics.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":1,"column":17}},{"source":"../../src/utils/generics.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":1,"column":19}},{"source":"../../src/utils/generics.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":1,"column":27}}],"sources":{"../../src/utils/generics.ts":"import { ApiEvent } from '../lib/ApiEvent'\nimport { ResourceField } from '../lib/ResourceField'\nimport { ResourceIdentifier } from '../lib/ResourceIdentifier'\nimport { ResourceFilter } from '../lib/ResourceFilter'\nimport { JsonApiRoot, JsonApiVersion, RelationshipMode } from './constants'\nimport { Debug } from './Debug'\n\nexport type AnyResource = ResourceIdentifier<any>\nexport type AnyFieldValue = AttributeValue | RelationshipValue\nexport type AnyResourceConstructor = ResourceConstructor<any>\nexport type AnyResourceInstance = InstanceType<AnyResourceConstructor>\n\nexport type TypeGuard<T> = (value: any, ...rest: Array<any>) => value is T\nexport type Transform<I, O = I> = (value: I, ...rest: Array<any>) => O\nexport type Predicate = Transform<any, boolean>\n\nexport type Resolved<T extends Promise<any>> = T extends Promise<infer R>\n  ? R\n  : never\n\nexport type ValuesOf<T extends {}> = T[keyof T]\nexport type KeysOf<T extends {}> = ValuesOf<\n  { [K in keyof T]: T[K] extends never ? never : K }\n>\n\n// todo: check regression, { type: string } used to be ResourceModel<any, any>\nexport type SpecificModel<M> = SpecificKey<\n  M extends { type: string } ? M['type'] : never\n> extends never\n  ? never\n  : M\n\nexport type WithoutNever<O extends {}> = Pick<O, KeysOf<O>>\nexport type WithoutType<O extends {}, T> = WithoutNever<\n  { [K in keyof O]: O[K] extends T ? never : O[K] }\n>\n\nexport type SpecificKey<T extends PropertyKey> = T &\n  ValuesOf<\n    {\n      [K in T]: Exclude<T, K> extends Extract<T, K>\n        ? Exclude<T | PropertyKey, T>\n        : never\n    }\n  >\n\nexport type NonEmptyArray<T> = { 0: T }\n\nexport type NotAny<T> = Exclude<1 | 0, T extends never ? 1 : 0> extends never\n  ? never\n  : T\n\nexport type NotImplicit<T> = unknown extends T ? never : T\nexport type NotUnkown<T> = NotAny<T> extends never\n  ? T\n  : unknown extends T\n  ? never\n  : T\n\nexport type NullOfNever<T> = T & null extends never ? null : T\n\nexport type WithoutImplicit<O extends {}> = WithoutNever<\n  { [K in keyof O]: NotImplicit<O[K]> extends never ? never : O[K] }\n>\n\nexport type WithOptional<T extends {}, K extends PropertyKey> = Omit<T, K> &\n  Partial<T>\n\nexport type ObjectOf<K extends PropertyKey, T = any> = { [P in K]: T }\n\nexport type ObjectWith<K extends PropertyKey> = ObjectOf<K, any>\nexport type ObjectWithout<K extends PropertyKey> = ObjectOf<any, any> &\n  Partial<ObjectOf<K, never>>\n\nexport type WrapValues<T, P extends PropertyKey> = {\n  [K in keyof T]: { [X in P]: T[K] }\n}\n\nexport type SerializableObject = {\n  [key: string]: SerializableValue\n}\n\nexport type SerializableArray = {\n  [key: number]: SerializableValue\n}\n\nexport type SerializableValue =\n  | string\n  | number\n  | boolean\n  | null\n  | SerializableObject\n  | SerializableArray\n\nexport type ValueType = {\n  boolean: boolean\n  function: Function\n  number: number\n  object: object\n  string: string\n  symbol: symbol\n  undefined: undefined\n}\n\nexport type Species<T> = NotAny<T> extends never\n  ? unknown\n  : T extends string\n  ? string\n  : never | T extends number\n  ? number\n  : never | T extends boolean\n  ? boolean\n  : never | T extends object\n  ? object\n  : never | T extends symbol\n  ? symbol\n  : never | T extends null\n  ? null\n  : never\n\n// JSON:API\nexport type ApiURL = string\nexport type ApiPath = string\n\nexport type ApiSetup = {\n  version: JsonApiVersion\n  encodeFieldName: Transform<string>\n  beforeRequest: Transform<any> // todo: define any\n}\n\nexport type ApiEventOrigin = any\nexport type ApiEventListener = (\n  event: ApiEvent<any>,\n  origin: ApiEventOrigin,\n) => void\n\nexport type ApiEventHandler = (event: ApiEvent<any>) => void\nexport type ApiEventData = any\nexport type ApiEventTime = number\n\nexport type ResourceFilterQuery = {\n  include: Array<string>\n  fields: Record<string, Array<string>>\n}\n\nexport type JsonApiResourceRelationshipData =\n  | Array<AnyResource>\n  | AnyResource\n  | null\n\nexport type JsonApiMetaData = Record<string, unknown>\nexport type JsonApiLinksData = Record<string, string>\nexport type JsonApiResourceAttributes = Record<string, AttributeValue>\nexport type JsonApiResourceRelationships = Record<\n  string,\n  {\n    [JsonApiRoot.DATA]: JsonApiResourceRelationshipData\n  }\n>\n\nexport type JsonApiResourceData = {\n  [JsonApiRoot.TYPE]: ResourceType\n  [JsonApiRoot.ID]: ResourceId\n  [JsonApiRoot.ATTRIBUTES]: JsonApiResourceAttributes\n  [JsonApiRoot.RELATIONSHIPS]: JsonApiResourceRelationships\n  [JsonApiRoot.LINKS]: JsonApiLinksData\n}\n\nexport type JsonApiIncludedData = Array<JsonApiResourceData>\n\nexport type JsonApiGetResponse = JsonApiBaseResponse &\n  (JsonApiSuccesResponse<any> | JsonApiErrorResponse)\n\nexport type JsonApiBaseResponse = {\n  [JsonApiRoot.LINKS]?: JsonApiLinksData\n  [JsonApiRoot.JSONAPI]?: JsonApiMetaData\n  [JsonApiRoot.META]?: JsonApiMetaData\n}\n\nexport type JsonApiSuccesResponse<D> = JsonApiBaseResponse & {\n  [JsonApiRoot.DATA]: D\n  [JsonApiRoot.INCLUDED]?: JsonApiIncludedData\n  [JsonApiRoot.ERRORS]?: never\n}\n\nexport type JsonApiErrorResponse = JsonApiBaseResponse & {\n  [JsonApiRoot.ERRORS]: Array<JsonApiErrorData>\n  [JsonApiRoot.DATA]?: never\n  [JsonApiRoot.INCLUDED]?: never\n}\n\nexport type JsonApiErrorData = {\n  [JsonApiRoot.ID]?: string\n  [JsonApiRoot.LINKS]?: JsonApiLinksData\n  [JsonApiRoot.META]?: JsonApiMetaData\n  status?: string | '400'\n  title?: string\n  detail?: string\n  source?: {\n    pointer?: string\n    parameter?: string\n  }\n}\n\nexport type AnyResourceFilter = ResourceFilter<string, AnyResourceFilterFields>\n\nexport type AnyResourceFilterFields = null | {\n  [key: string]: Array<string>\n}\n\nexport type JsonApiParameterValue = string | number | Array<string | number>\nexport type JsonApiQueryValue =\n  | JsonApiParameterValue\n  | Record<string, JsonApiParameterValue>\n\nexport type JsonApiQuery = Record<string, JsonApiQueryValue>\n\n// RESOURCE\nexport type IdentifierKey = keyof AnyResource\n\nexport type ResourceId = string\nexport type ResourceType = string\nexport type FieldName = string\n\nexport type Model<T extends ResourceType, M> = {\n  [K in keyof Omit<M, IdentifierKey>]: RelationshipFieldModel<\n    M[K]\n  > extends never\n    ? AttributeFieldValue<M[K]> extends never\n      ? never\n      : M[K]\n    : M[K]\n} & {\n  type: T\n  id: ResourceId\n}\n\nexport type AttributeObjectValue = {\n  [key: string]: AttributeValue\n}\n\nexport type AttributeArrayValue = {\n  [key: number]: AttributeValue\n}\n\nexport type AttributeValue =\n  | number\n  | string\n  | boolean\n  | null\n  | AttributeObjectValue\n  | AttributeArrayValue\n\nexport type RelationshipValue = Array<AnyResource> | AnyResource | null\n\nexport type Attribute<T> = RequiredOrOptionalAttribute<T> extends never\n  ? never\n  : T\n\nexport type RequiredAttribute<\n  T extends Exclude<AttributeValue, null>\n> = Attribute<T>\nexport type RequiredStringAttribute = RequiredAttribute<string>\nexport type RequiredNumberAttribute = RequiredAttribute<number>\nexport type RequiredBooleanAttribute = RequiredAttribute<boolean>\n\nexport type OptionalAttribute<\n  T extends Exclude<AttributeValue, null>\n> = Attribute<T | null>\nexport type OptionalStringAttribute = OptionalAttribute<string>\nexport type OptionalNumberAttribute = OptionalAttribute<number>\nexport type OptionalBooleanAttribute = OptionalAttribute<boolean>\n\nexport type ToOne = RelationshipMode.TO_ONE\nexport type ToMany = RelationshipMode.TO_MANY\n\nexport type Relationship<\n  T extends ToOne | ToMany,\n  M extends AnyResource\n> = SpecificKey<T> extends never\n  ? never\n  : SpecificModel<M> extends never\n  ? never\n  : T extends ToOne\n  ? M | null\n  : Array<M>\n\nexport type RelationshipToOne<M extends AnyResource> = Relationship<ToOne, M>\nexport type RelationshipToMany<M extends AnyResource> = Relationship<ToMany, M>\n\nexport type ResourceIdentifierConstructor<T extends ResourceType> = {\n  new (type: T, id: ResourceId): ResourceIdentifier<T>\n}\n\nexport type ResourceConstructor<\n  M extends Model<ResourceType & M['type'], M>\n> = {\n  type: ResourceType & M['type']\n  fields: Record<FieldName, ResourceField>\n  Identifier: ResourceIdentifierConstructor<ResourceType & M['type']>\n  new (item: M): M\n}\n\nexport type RequiredOrOptionalAttribute<T> = Extract<T, null> extends never\n  ? Exclude<T, AttributeValue> extends never\n    ? T\n    : never\n  : Exclude<T, AttributeValue | null> extends never\n  ? Exclude<T, null> extends never\n    ? never\n    : T\n  : never\n\nexport type AttributeFieldValue<T> = NotAny<T> & Attribute<T>\n\nexport type RelationshipFieldModel<T> = NotAny<\n  (T extends AnyResource | null ? never : T) extends never\n    ? SpecificKey<T extends null ? 0 : 1> extends never\n      ? SpecificModel<Exclude<T, null>>\n      : never\n    : Exclude<T, Array<AnyResource>> extends never\n    ? T extends Array<AnyResource>\n      ? T[number]\n      : never\n    : never\n>\n\nexport type ModelType<M> = M extends AnyResource ? M['type'] : never\n\nexport type RelationshipFieldModelType<T> = ModelType<RelationshipFieldModel<T>>\n\nexport type AddResourceData<\n  M extends Model<ResourceType & M['type'], M>\n> = Partial<M>\n\n// RESOURCE FRAGMENT\n\ntype NonGenericString<T extends string> = string extends T ? never : T\n\ntype AnyResourceFieldOptions = { type: PropertyKey; fields: any }\n\nexport type ModelFilter<F extends AnyResourceFieldOptions | Debug.Any> = {\n  [K in (Exclude<F, Debug.Any>)['type']]: Extract<F, { type: K }>['fields'][] &\n    NonEmptyArray<Extract<F, { type: K }>['fields']>\n}\n\nexport type ResourceFragmentOptions<M extends AnyResource> = null | Partial<\n  ModelFilter<ResourceFragmentFields<M>>\n>\n\ntype FilteredRelationshipField<T> = T extends AnyResource\n  ? Pick<T, IdentifierKey>\n  : T\n\ntype FilteredRelationshipFragment<\n  M extends AnyResource,\n  F extends { [key: string]: string }\n> = WithoutNever<\n  {\n    [K in keyof M]: K extends IdentifierKey\n      ? M[K]\n      : K extends F[M['type']]\n      ? M[K] extends Array<AnyResource>\n        ? Array<FilteredRelationshipField<M[K][any]>>\n        : FilteredRelationshipField<M[K]>\n      : never\n  }\n>\n\ntype FilteredResourceField<\n  T,\n  F extends { [key: string]: string }\n> = T extends Array<AnyResource>\n  ? Array<FilteredRelationshipFragment<T[number], F>>\n  : Extract<T, AnyResource> extends never\n  ? T\n  : FilteredRelationshipFragment<Extract<T, AnyResource>, F> | null\n\n// todo: check WithoutNever for ResourceFragment regression\ntype FilteredResourceFragment<\n  M extends AnyResource,\n  F extends { [key: string]: string }\n> = WithoutNever<\n  {\n    [K in keyof M]: K extends IdentifierKey\n      ? M[K]\n      : K extends F[M['type']]\n      ? FilteredResourceField<M[K], F>\n      : never\n  }\n>\n\ntype DefaultResourceFragment<M extends AnyResource> = {\n  [K in keyof M]: K extends IdentifierKey\n    ? M[K]\n    : FilteredResourceField<M[K], { [key: string]: IdentifierKey }>\n}\n\nexport type ResourceFragment<\n  M extends AnyResource,\n  F extends Record<string, any> | null\n> = F extends {}\n  ? FilteredResourceFragment<M, { [K in keyof F]: F[K][number] }>\n  : DefaultResourceFragment<M>\n\ntype ResourceModelFields<M extends AnyResource> = Exclude<\n  keyof M,\n  IdentifierKey\n>\n\ntype ResourceModelFieldOptions<M extends AnyResource> = NonGenericString<\n  M['type']\n> extends never\n  ? never\n  : ValuesOf<\n      {\n        [K in M['type']]: {\n          type: K\n          fields: ResourceModelFields<Extract<M, { type: K }>>\n        }\n      }\n    >\n\nexport type InspectResourceFragment<M extends AnyResource> = Extract<\n  ResourceFragmentOptions<M>,\n  Debug.Any\n>\n\ntype ResourceModelFieldOptionsExept<R, T extends string> = R extends AnyResource\n  ? R['type'] extends T\n    ? never\n    : ResourceModelFieldOptions<R>\n  : never\n\ntype ModelRelationshipsExept<M, T extends string> = ValuesOf<\n  {\n    [K in keyof M]: M[K] extends Array<AnyResource>\n      ? ResourceModelFieldOptionsExept<M[K][number], T>\n      : ResourceModelFieldOptionsExept<Extract<M[K], AnyResource>, T>\n  }\n>\n\nexport type ResourceFragmentFields<M extends AnyResource> =\n  | ResourceModelFieldOptions<M>\n  | ResourceFragmentFieldsB<M, M['type']>\n\ntype ResourceFragmentFieldsB<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsC<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsC<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<{ [K in keyof M]: ResourceFragmentFieldsD<M[K], T> }>\n  : never\n\ntype ResourceFragmentFieldsD<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsE<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsE<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsF<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldG<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsH<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsI<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsJ<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsK<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsL<M, T extends string> = M extends AnyResource\n  ?\n      | ModelRelationshipsExept<M, T | M['type']>\n      | ValuesOf<\n          { [K in keyof M]: ResourceFragmentFieldsLimit<M[K], T | M['type']> }\n        >\n  : never\n\ntype ResourceFragmentFieldsLimit<M, T extends string> = M extends AnyResource\n  ? M['type'] extends T\n    ? Debug.Info<\n        'Exhausted relationships depth (circular reference)',\n        M['type']\n      >\n    : Debug.Error<\n        'Exceeded relationships depth (too many redirects)',\n        M['type']\n      >\n  : never\n"},"lineCount":null}},"error":null,"hash":"245913d9bcd66b2af766037d7d4a0134","cacheData":{"env":{}}}